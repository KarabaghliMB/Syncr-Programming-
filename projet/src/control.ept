open Globals
open Utilities
open Debug

node turn_decoder(sens : sensors)
     	returns (turn : float)
var rc : color; r, g, b  : float;
let
  rc = sens.s_road;
  r = Mathext.float(rc.red);
  g = Mathext.float(rc.green);
  b = Mathext.float(rc.blue);
  turn = (r -. g)/.(b);
  (*Exemple d'uttilisation des fonctions de deboggage*)
  (*() = dbg("ping \n");
  () = dbg_float("rouge = ", r);
  () = dbg_float("vert = ", g);
  () = dbg_float("bleu = ", b);*)
tel






node move_forward(sens : sensors; speed : float)
     	returns (rspeed : wheels; finished : bool)
var rc : color; turn, v_turn, v_max : float;
let
  (*() = dbg_float("speed = ", speed);*)
  rc = sens.s_road;
  turn = turn_decoder(sens);
  (*Le 20.83 a été deduit par experimentation*)
  v_max = 20.83 *. speed;
  (*() = dbg_float("v_max = ", v_max);
  () = dbg(" ");*)
  v_turn = v_max *. (0.25);
  (*Note c est le contraire de ce q indiquai la methodologie conseille mais ça marhe...*)
  (*(v_max /. 2) car on ne dois jamais depaser la vitesse de speed *)
  rspeed = { left = (v_max)-. (v_turn *. turn);
  	   right = (v_max) +. (v_turn *. turn) };
  finished = if compare_colors(rc, green) >. 0.9 then true
  	     else false;
	     
  (*() = dbg_float(" roue droite = ", rspeed.left);
  () = dbg_float(" roue gauche = ", rspeed.right);*)
tel

node controller(sens : sensors; iti : itielts)
       returns (rspeed : wheels; arriving : bool)
var vmax : float; last cpt : int = 0; ordre : itielt;
let
  (*iti est un tableaux de itielt et pas un seul itielt...*)
  automaton
	state Avancer
	      do ordre = iti.[cpt] default {act = Go; param = 0.0};
	         vmax = ordre.param;
(*Pour modif la vitesse lu c'est le .map qu'il faut modifier pas le epi*)
       	     	 (rspeed, arriving) = move_forward(sens, vmax);
	      until arriving then Incr
	state Incr
	      do cpt = last cpt + 1;
	      ordre = {act = Go; param = 0.0};
	      vmax = 0.0;
	      rspeed = {left = 0.0; right = 0.0};
	      arriving = false;
	      until true then Avancer
  end
tel
